"""
Every character classes inherit from the :class:`Character()` defined below.

--

Author : DrLarck

Last update : 18/08/19 (DrLarck)
"""

# dependancies
import asyncio

# attribute
from utility.cog.character.attribute.info import Character_info
from utility.cog.character.attribute.image import Character_image
from utility.cog.character.attribute.type import Character_type
from utility.cog.character.attribute.rarity import Character_rarity

from utility.cog.character.attribute.posture import Character_posture
from utility.cog.character.attribute.health import Character_health
from utility.cog.character.attribute.ki import Character_ki
from utility.cog.character.attribute.damage import Character_damage

from utility.cog.character.attribute.defense import Character_defense
from utility.cog.character.attribute.regenation import Character_regen

# character class
class Character:
    """
    Every character classes inherit from this one.

    Defines what a character is and all the possible interaction you can have with it.

    - Attribute : 

    `info` : Represents the character's basic infos.

    `image` : Represents the character's images

    `type` : Represents the character's type.

    `rarity` : Represents the character's rarity.

    `level` : Represents the character's level.

    `posture` : Represents the character's posture.

    `health` = Represents the character's health.

    `ki` : Represents the character's ki.

    `damage` : Represents the character's damage.

    `critical_chance` : Represents the character's crit chance.

    `critical_bonus` : Represents the character's crit bonus.

    `defense` : Represents the character's defense.

    `regeneration` : Represents the character's regen.

    `bonus` : Represents the character's bonus effect.

    `malus` Represents the character's malus effect.

    `ability` : Represents the character's abilities.

    `passive` : Represents the character's passive.

    `leader` : Represents the character's leader.

    `enhancement` : dict  {
        "star" : 0,
        "training" : dict {
            "defense" : dict {
                "health" : 0,
                "armor" : 0,
                "spirit" : 0
            },
            "damage" : dict {
                "physical" : 0,
                "ki" : 0
            }
        }
    }

    - Method :

    :coro:`init()` : Translates strings and initializes the stats.

    :coro:`set_stat()` : Initializes the stats.

    :coro:`receive_damage()` : Inflicts the damages to the character and triggers the effects based on the type of the attack and if the character dies or not.

    :coro:`use_ability()` : Uses the passed ability as parameter.

    :coro:`trigger_passive()` : Triggers the passive ability.

    :coro:`trigger_leader()` : Triggers the leader skill.

    :coro:`bot()` : Triggers the AI.
    """

    # attribute
    def __init__(self):
        # bot
        self.is_npc = False  # if true, the action will automatically be managed by the AI
        
        # basic info
        self.info = Character_info()
        self.image = Character_image()
        self.type = Character_type()
        self.rarity = Character_rarity()

        # characteristics
        self.level = 0

        # represent the character's posture
        # if all the postures are set to False it means that the character is
        # attacking
        # default : "attacking" = True
        self.posture = Character_posture()

        # if the current health reaches 0, the character dies
        self.health = Character_health()

        # by default the maximum ki is 100
        self.ki = Character_ki()

        # 2 types of damage : Physical and Ki one
        self.damage = Character_damage()

        # the critical values are in %
        self.critical_chance = 0
        self.critical_bonus = 0

        # 2 types of defense : Physical and Ki, repectively "Armor" and "Spirit"
        # the "reduction" key value is in % as well as "parry" and "dodge"
        self.defense = Character_defense()

        # represents the stats that are generated by the character at each turn
        self.regeneration = Character_regen()

            # bonus stat
            # used for the stats calculation
            # each value represent an amount of item used
            # basically the player won't be able to use more than
            # 10 training items
        self.enhancement = {
            "star" : 0,
            "training" : {
                "defense" : {
                    "health" : 0,
                    "armor" : 0,
                    "spirit" : 0
                },
                "damage" : {
                    "physical" : 0,
                    "ki" : 0
                }
            }
        }

        # effect
        # list of effects
        self.bonus = []
        self.malus = []

        # ability
        # list of abilities
        self.ability = []
        self.passive = []
        self.leader = []
        
    #####################
    # method
        # init
    async def init(self):
        """
        `coroutine`

        Initializes the character by : 
        - Translating its name
        - Setting up its characteristics

        --

        Return : None
        """

        return
    
    async def set_stat(self):
        """
        `coroutine`

        Initializes the character's stats.

        --

        Return : None
        """

        return
    
    async def receive_damage(self, damage):
        """
        `coroutine`

        Applies the received damages.

        - Parameter :

        `damage` : Represents the damage received. (int)

        --

        Return : None
        """
        
        # only applies the effect if the character is alive
        if(self.health.current > 0):
            # check if the target is gonna die after this attack
            gonna_die = False

            if(damage >= self.health.current):  # the damages are going to kill it
                gonna_die = True

            # apply the damage
            self.health.current -= damage
            await self.health.health_limit()

            if(gonna_die):  # if the attack killed the character
                # trigger the dying effects.
                pass

        return
    
    # ability
    async def get_ability(self, client, ctx, target, team_a, team_b, ability_index):
        """
        `coroutine`

        Uses the passed ability.

        - Parameter : 

        `client` : Represents the `discord.Client`.

        `ctx` : Represents the `commands.Context`.

        `target` : Represents a `Character()` instance.

        `team_a` | `team_b` : Represents a list of characters representing a team. Team a is the caster's team.

        `ability_index` : Represents the ability index in the `ability` list.

        --

        Return : `Ability()` instance.
        """
        
        # find the ability then create an instance of it
        ability = self.ability[ability_index]

        # pass the parameter to the ability instance
        ability = ability(
            client,
            ctx,
            self,
            target,
            team_a,
            team_b
        )

        return(ability)
        
        # triggers
    async def trigger_passive(self):
        """
        `coroutine`

        Triggers all the passive skills.

        --

        Return : None
        """

        # init
        passive = self.passive

        if(len(passive) > 0):  # if there is some passive skills in it
            for _passive in passive:  # triggers the effects one by one
                await asyncio.sleep(0)

                await _passive.trigger()
        
        else:  # if the passive list is empty we return
            return
        
        return
    
    async def trigger_leader(self):
        """
        `coroutine`

        Triggers all the leader skills.

        --

        Return : None
        """

        # init
        leader = self.leader

        if(len(leader) > 0):
            for _leader in leader:
                await asyncio.sleep(0)

                await _leader.trigger()
        
        else:
            return
        
        return
    
        # artificial intelligence
    async def bot(self, turn):
        """
        `coroutine`

        Defines the character gameplay. The bot will play as defined in this method.

        - Parameter :

        `turn` : Represents the current turn number.

        --

        Return : None
        """

        return